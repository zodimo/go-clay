# Story 1.1: Create clay.yml for c-for-go bindings for C/clay.h

## Status

Draft

## Story

**As a** developer,
**I want** to generate Go bindings for the `clay.h` C library using `c-for-go`,
**so that** I can use the `clay` UI layout library in my Go application.

## Acceptance Criteria

1. A `clay.yml` configuration file is created in the root of the project.
2. The `clay.yml` file is configured to generate Go bindings for the `clay.h` C library.
3. The generated Go bindings are complete and correctly map the C functions, structs, enums, and other definitions from `clay.h`.
4. A strategy for handling the single-header library nature of `clay.h` (with the `CLAY_IMPLEMENTATION` macro) is documented.

## Tasks / Subtasks

- [ ] Task 1 (AC: 1, 2): Create and configure `clay.yml`.
  - [ ] Subtask 1.1: Analyze `clay.h` to identify all public functions, structs, enums, and macros that need to be included in the bindings.
  - [ ] Subtask 1.2: Create the `clay.yml` file in the project root.
  - [ ] Subtask 1.3: Configure `clay.yml` to specify the `clay.h` header file as the input.
  - [ ] Subtask 1.4: Add any necessary `c-for-go` directives to `clay.yml` to handle any complexities in `clay.h`, such as macros, packed structs, and function pointers.
- [ ] Task 2 (AC: 4): Document the strategy for `CLAY_IMPLEMENTATION`.
  - [ ] Subtask 2.1: Create a C file (e.g., `clay_impl.c`) that defines `CLAY_IMPLEMENTATION` and includes `clay.h`.
  - [ ] Subtask 2.2: Document in the `clay.yml` or a separate README how to compile and link this implementation file with the Go application.
- [ ] Task 3 (AC: 3): Generate and verify the Go bindings.
  - [ ] Subtask 3.1: Run `c-for-go` to generate the Go bindings.
  - [ ] Subtask 3.2: Review the generated Go code to ensure all expected functions, structs, and enums are present and correctly typed.
  - [ ] Subtask 3.3: Write a small Go example that uses the generated bindings to create a simple UI with `clay` to verify the bindings work correctly.

## Dev Notes

*   **Architecture:** No specific guidance found in architecture docs, as they are missing. The developer should rely on the `clay.h` header file as the primary source of truth.
*   **`clay.h` Analysis:** The `clay.h` file is a single-header library. It contains a large number of structs, enums, and functions for creating and managing a UI layout. Special attention should be paid to:
    *   Macros: `CLAY_ID`, `CLAY_SIZING_FIT`, etc. These will likely need to be implemented as Go functions.
    *   Packed Structs: `CLAY_PACKED_ENUM`. `c-for-go` may need specific configuration to handle these correctly.
    *   Function Pointers: `Clay_SetMeasureTextFunction`, `Clay_OnHover`. The Go bindings will need to support passing Go functions as callbacks.
    *   `CLAY_IMPLEMENTATION`: As noted in the tasks, a C file needs to be created to host the implementation of the library. This file will need to be compiled and linked with the Go application.
*   **`c-for-go` Configuration:** The `clay.yml` file will need to be carefully crafted to handle the complexities of `clay.h`. The developer should consult the `c-for-go` documentation (context7 mcp server with the library id of c-for-go) for guidance on handling macros, packed structs, and function pointers.

## Testing

*   No specific guidance found in architecture docs.
*   The developer should create a small example Go application that uses the generated bindings to create a simple UI. This will serve as a basic integration test to verify the bindings are working correctly.

## Change Log

| Date | Version | Description | Author |
| --- | --- | --- | --- |

## Dev Agent Record

### Agent Model Used

{{agent_model_name_version}}

### Debug Log References

### Completion Notes List

### File List

## QA Results
